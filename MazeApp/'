#include "MazeLayer.h"
#include "Renderer/Renderer2D.h"
#include <SFML/Graphics.hpp>
#include <random>
#include <string>

float xoffset = 16;
float yoffset = 16;
enum {
  RED,
  BLUE,
  BLACK,
  WHITE,
  GRAY,
  PINK,
};
const std::vector<Color> Colors = {
    Color{200, 0, 0, 255},     // RED
    Color{0, 0, 200, 255},     // BLUE
    Color{0, 0, 0, 255},       // BLACK
    Color{255, 255, 255, 255}, // WHITE
    Color{224, 224, 224, 255}, // GRAY
    Color{255, 192, 203, 255}, // PINK
};
const int cellsize = 32;
enum { UP, DOWN, RIGHT, LEFT };
class Cell {
public:
  Cell() {
    for (int i = 0; i < 4; i++) {
      side[i] = nullptr;
      block[i] = false;
    }
  }
  void Draw(float row, float col) {
    Color FillColor;
    Color WallColor = Colors[BLACK];
    float thick = 2;
    if (!select) {
      FillColor = Colors[GRAY];
    } else {
      FillColor = Colors[PINK];
    }
    Renderer2D::DrawFillRectangle(col * cellsize + xoffset,
                                  row * cellsize + yoffset, cellsize, cellsize,
                                  FillColor);
    for (int i = 0; i < 4; i++) {
      if (side[i] == nullptr) {
        float x[2], y[2];
        switch (i) {
        case LEFT:
          x[0] = col * cellsize + thick / 4 + 1;
          y[0] = row * cellsize + 1;
          x[1] = x[0];
          y[1] = y[0] + cellsize - 1;
          break;
        case RIGHT:
          x[0] = (col + 1) * cellsize - thick / 4 + 1;
          y[0] = row * cellsize + 1;
          x[1] = x[0];
          y[1] = y[0] + cellsize - 1;
          break;
        case UP:
          x[0] = col * cellsize;
          y[0] = row * cellsize + thick / 4;
          x[1] = x[0] + cellsize;
          y[1] = y[0];
          break;
        case DOWN:
          x[0] = col * cellsize;
          y[0] = (row + 1) * cellsize - thick / 4;
          x[1] = x[0] + cellsize;
          y[1] = y[0];
          break;
        }
        x[0] += xoffset;
        x[1] += xoffset;
        y[0] += yoffset;
        y[1] += yoffset;
        Renderer2D::DrawLine(x[0], y[0], x[1], y[1], thick / 2, WallColor);
      }
    }
  }
  Cell *side[4];
  bool block[4];
  bool select;
};
class Ground {
public:
  bool reset = false;
  const static int ROW = 5;
  const static int COL = 5;
  Cell cells[ROW][COL];
  std::mt19937 m_mt;
  bool visited[ROW][COL];
  std::vector<std::vector<int>> graph;
  int m_sel_row;
  int m_sel_col;
  Ground() {}
  void Init() {
    reset = true;

    for (int i = 0; i < ROW; i++) {
      for (int j = 0; j < COL; j++) {
        visited[i][j] = false;
      }
    }
    for (int i = 0; i < ROW; i++) {
      cells[i][0].block[LEFT] = true;
      cells[i][COL - 1].block[RIGHT] = true;
    }
    for (int i = 0; i < COL; i++) {
      cells[0][i].block[UP] = true;
      cells[ROW - 1][i].block[DOWN] = true;
    }
    m_mt = std::mt19937(100);
  }
  void Draw() {
    for (int r = 0; r < ROW; r++) {
      for (int c = 0; c < COL; c++) {
        cells[r][c].Draw(r, c);
      }
    }
  }
  void Update() {
    if (reset) {
      int r0 = m_mt() % ROW;
      int c0 = m_mt() % COL;
      m_sel_row = r0;
      m_sel_col = c0;
      visited[r0][c0] = true;
      cells[r0][c0].select = true;
      graph.resize(ROW * COL);
      reset = false;
    } else {
      for (int i = 0; i < 4; i++) {
        int r2, c2;
        r2 = m_sel_row;
        c2 = m_sel_col;
        switch (i) {
        case 0:
          r2 -= 1;
          break;
        case 1:
          r2 += 1;
          break;
        case 2:
          c2 -= 1;
          break;
        case 3:
          c2 += 1;
          break;
        }
        if (0 <= r2 && r2 < ROW && 0 <= c2 && c2 < COL) {
          if (!visited[r2][c2]) {
            graph[m_sel_row * COL + m_sel_col].emplace_back(r2 * COL + c2);
          }
        }
      }
    }
  }
};
Ground ground;
uint64_t gtime = 0;
constexpr const int FPS = 2;
constexpr const int SPF = 1000 / (double)FPS;

MazeLayer::MazeLayer() : Layer("MazeLayer") {}
void MazeLayer::OnUpdate(Timestep &ts) {
  PROFILE_FUNCTION();
  gtime += ts.GetMilliseconds();
  if (gtime >= SPF) {
    gtime = gtime % SPF;
    ground.Update();
    Renderer2D::BeginScene();
    Renderer2D::Clear(255, 255, 255);
    ground.Draw();
    Renderer2D::EndScene();
  }
}

void MazeLayer::OnGuiRender() { PROFILE_FUNCTION(); }

void MazeLayer::OnEvent(Event &e) {
  EventDispatcher dispatcher(e);
  dispatcher.Dispatch<KeyPressedEvent>(BIND_EVENT_FN(OnKeyPressed));
  dispatcher.Dispatch<AppUpdateEvent>(BIND_EVENT_FN(OnAppUpdate));
}

bool MazeLayer::OnAppUpdate(AppUpdateEvent &e) { return true; }
bool MazeLayer::OnKeyPressed(KeyPressedEvent &e) {
  switch (e.GetKeyCode()) {
  case sf::Keyboard::A:
    break;
  }
  return true;
}

void MazeLayer::OnAttach() {
  PROFILE_FUNCTION();
  CORE_INFO("Attach");
  Application &app = Application::Get();
  m_window = static_cast<sf::RenderWindow *>(app.GetWindow().GetNativeWindow());
  Renderer2D::Init(m_window);
  ground.Init();
  Renderer2D::BeginScene();
  Renderer2D::Clear(255, 255, 255);
  ground.Draw();
  Renderer2D::EndScene();
}

void MazeLayer::OnDetach() { PROFILE_FUNCTION(); }
